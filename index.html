<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>What the Dog Doing?</title>
<style>
:root {
  --bg0: #0f1219;
  --bg1: #1f2634;
  --track: #2a3242;
  --line: #95a4c5;
  --ink: #050608;
  --red: #db3152;
  --gold: #f6c54f;
  --mint: #5de1bf;
}
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  overflow: hidden;
  background: radial-gradient(circle at 50% 15%, #2b3851, var(--bg0) 55%);
  font-family: "Trebuchet MS", "Avenir Next", "Segoe UI", sans-serif;
  color: #fff;
}
body {
  touch-action: none;
}
canvas {
  width: 100%;
  height: 100%;
  display: block;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const c = document.getElementById("c");
  const x = c.getContext("2d", { alpha: false });

  let W = 360;
  let H = 740;
  let dpr = 1;
  let baseY = 0;
  let lanePad = 0;

  const st = {
    started: 0,
    dead: 0,
    p: 0,
    speed: 170,
    boost: 0,
    score: 0,
    best: +localStorage.hd_best_score || 0,
    notes: 0,
    coffee: 0,
    combo: 0,
    comboT: 0,
    last: "",
    hintT: 13,
    flash: 0,
    shake: 0,
    lane: 0,
    laneT: 0,
    z: 0,
    vz: 0,
    j2: 1,
    slide: 0,
    wall: 0,
    hold: 0,
    gid: -1,
    aura: 0,
    t: 0,
  };

  const obs = [];
  const anchors = [];
  const particles = [];

  let nextY = 700;
  let pointerId = -1;
  let downX = 0;
  let downY = 0;
  let downT = 0;
  let lastFrame = 0;
  let audio = null;

  function laneX(lane) {
    return W * 0.5 + lane * lanePad;
  }

  function clamp(v, a, b) {
    return v < a ? a : (v > b ? b : v);
  }

  function resize() {
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.max(320, window.innerWidth | 0);
    H = Math.max(560, window.innerHeight | 0);
    c.width = (W * dpr) | 0;
    c.height = (H * dpr) | 0;
    x.setTransform(dpr, 0, 0, dpr, 0, 0);
    x.imageSmoothingEnabled = false;
    baseY = H * 0.77;
    lanePad = W * 0.24;
  }

  function sfx(freq, dur, type, vol) {
    if (!audio) return;
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.type = type || "triangle";
    o.frequency.value = freq;
    g.gain.value = vol || 0.035;
    g.gain.exponentialRampToValueAtTime(0.0001, audio.currentTime + dur);
    o.connect(g).connect(audio.destination);
    o.start();
    o.stop(audio.currentTime + dur);
  }

  function burst(xx, yy, col, n, v) {
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const sp = (0.25 + Math.random()) * v;
      particles.push({
        x: xx,
        y: yy,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        t: 0.2 + Math.random() * 0.35,
        c: col,
      });
    }
  }

  function addObstacle(t, y, lane) {
    obs.push({ t, y, l: lane, hit: 0 });
  }

  function addAnchor(y, lane) {
    anchors.push({ y, l: lane, used: 0 });
  }

  function seedTutorial() {
    addObstacle(0, 130, 0);  // jump
    addObstacle(2, 250, 0);  // wallrun lane shift
    addObstacle(1, 360, -1); // slide
    addAnchor(475, 0);       // grapple tutorial
    addObstacle(3, 540, 0);  // grapple gate
    addObstacle(4, 610, 1);  // note
    addObstacle(5, 680, -1); // coffee
  }

  function spawnRandom() {
    while (nextY < st.p + H * 1.8) {
      const r = Math.random();
      const lane = [-1, 0, 1][(Math.random() * 3) | 0];
      if (r < 0.22) {
        addObstacle(0, nextY, lane);
      } else if (r < 0.45) {
        addObstacle(1, nextY, lane);
      } else if (r < 0.64) {
        addObstacle(2, nextY, lane);
      } else if (r < 0.78) {
        const a = lane;
        const b = a === 0 ? (Math.random() < 0.5 ? -1 : 1) : 0;
        addObstacle(0, nextY, a);
        addObstacle(2, nextY + 28, b);
      } else {
        addAnchor(nextY - 58, lane);
        addObstacle(3, nextY, 0);
      }

      if (Math.random() < 0.55) addObstacle(4, nextY + 38, [-1, 0, 1][(Math.random() * 3) | 0]);
      if (Math.random() < 0.18) addObstacle(5, nextY + 52, [-1, 0, 1][(Math.random() * 3) | 0]);

      nextY += 78 + Math.random() * 100 + Math.min(36, st.speed * 0.08);
    }

    while (obs.length && obs[0].y < st.p - 220) obs.shift();
    while (anchors.length && anchors[0].y < st.p - 220) anchors.shift();
  }

  function action(name) {
    if (!st.started || st.dead) return;
    if (st.comboT > 0 && st.last && st.last !== name) {
      st.combo++;
      st.score += st.combo * 7;
      st.flash = 0.08;
    } else {
      st.combo = 1;
    }
    st.last = name;
    st.comboT = 1.25;
  }

  function moveSide(dir) {
    st.laneT = dir;
    st.wall = 0.34;
    st.boost = Math.max(st.boost, 40);
    action("wall");
    sfx(280, 0.07, "square", 0.03);
    burst(laneX(st.lane), baseY + 8, "#6fa2ff", 8, 80);
  }

  function jump() {
    if (st.z < 4) {
      st.vz = 670;
      st.j2 = 1;
      action("jump");
      sfx(420, 0.08, "triangle", 0.04);
    } else if (st.j2 > 0) {
      st.j2 = 0;
      st.vz = 620;
      action("double");
      sfx(560, 0.08, "triangle", 0.03);
    }
  }

  function slide() {
    if (st.slide > 0) return;
    st.slide = 0.42;
    action("slide");
    if (st.z > 10) st.vz -= 200;
    sfx(210, 0.1, "sawtooth", 0.028);
    burst(laneX(st.lane), baseY + 12, "#9eb4df", 10, 60);
  }

  function tryAttachGrapple() {
    if (!st.hold || st.gid >= 0 || st.dead) return;
    let best = -1;
    let bestDy = 9999;
    for (let i = 0; i < anchors.length; i++) {
      const a = anchors[i];
      if (a.used) continue;
      const dy = a.y - st.p;
      if (dy < -18 || dy > 180) continue;
      if (Math.abs(a.l - st.lane) > 1.2) continue;
      if (dy < bestDy) {
        bestDy = dy;
        best = i;
      }
    }
    if (best >= 0) {
      st.gid = best;
      anchors[best].used = 1;
      action("grapple");
      sfx(690, 0.05, "square", 0.03);
      burst(laneX(st.lane), baseY - st.z * 0.3, "#f6c54f", 9, 90);
    }
  }

  function kill(reason) {
    if (st.dead) return;
    st.dead = 1;
    st.hold = 0;
    st.gid = -1;
    st.combo = 0;
    st.comboT = 0;
    st.shake = 0.35;
    st.flash = 0.3;
    burst(laneX(st.lane), baseY - st.z * 0.3, "#ff6d7f", 20, 130);
    sfx(120, 0.22, "sawtooth", 0.045);
    st.best = Math.max(st.best, st.score | 0);
    localStorage.hd_best_score = st.best;
    st.reason = reason;
  }

  function reset() {
    obs.length = 0;
    anchors.length = 0;
    particles.length = 0;

    st.dead = 0;
    st.p = 0;
    st.speed = 170;
    st.boost = 0;
    st.score = 0;
    st.notes = 0;
    st.coffee = 0;
    st.combo = 0;
    st.comboT = 0;
    st.last = "";
    st.hintT = 13;
    st.flash = 0;
    st.shake = 0;
    st.lane = 0;
    st.laneT = 0;
    st.z = 0;
    st.vz = 0;
    st.j2 = 1;
    st.slide = 0;
    st.wall = 0;
    st.hold = 0;
    st.gid = -1;
    st.aura = 0;
    st.reason = "";
    nextY = 700;

    seedTutorial();
  }

  function checkCollisions() {
    for (let i = 0; i < obs.length; i++) {
      const o = obs[i];
      const dy = o.y - st.p;
      if (dy < -26 || dy > 26) continue;

      if (o.t >= 4) {
        if (o.hit) continue;
        if (Math.abs(o.l - st.lane) > 0.45) continue;

        o.hit = 1;
        if (o.t === 4) {
          st.score += 70;
          st.notes++;
          action("note");
          sfx(850, 0.05, "triangle", 0.03);
          burst(laneX(o.l), baseY - 14, "#ffe493", 8, 80);
        } else {
          st.score += 45;
          st.coffee++;
          st.boost += 130;
          action("coffee");
          sfx(320, 0.07, "square", 0.03);
          burst(laneX(o.l), baseY - 16, "#ffab66", 10, 95);
        }
        continue;
      }

      if (o.t === 3) {
        if (st.z < 105) kill("Need grapple height");
        continue;
      }

      if (Math.abs(o.l - st.lane) > 0.45) continue;

      if (o.t === 0) {
        if (st.z < 38) kill("Jump over");
      } else if (o.t === 1) {
        const safeSlide = st.slide > 0 && st.z < 32;
        const safeHigh = st.z > 92;
        if (!safeSlide && !safeHigh) kill("Slide under");
      } else if (o.t === 2) {
        if (st.wall <= 0 && st.z < 96) kill("Tap side walls");
      }
    }
  }

  function update(dt) {
    st.t += dt;

    if (!st.started || st.dead) {
      if (st.flash > 0) st.flash -= dt;
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.t -= dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 280 * dt;
        if (p.t <= 0) particles.splice(i, 1);
      }
      return;
    }

    if (st.comboT > 0) st.comboT -= dt;
    else st.combo = 0;

    if (st.hintT > 0) st.hintT -= dt;

    st.speed = Math.min(330, st.speed + dt * 1.2);
    st.boost = Math.max(0, st.boost - dt * 120);
    st.p += (st.speed + st.boost) * dt;

    if (st.slide > 0) st.slide -= dt;
    if (st.wall > 0) st.wall -= dt;
    if (st.flash > 0) st.flash -= dt;
    if (st.shake > 0) st.shake -= dt;

    st.lane += (st.laneT - st.lane) * Math.min(1, dt * 13);
    st.aura += dt * 8;

    tryAttachGrapple();

    if (st.gid >= 0) {
      const g = anchors[st.gid];
      if (!g || !st.hold || g.y < st.p - 40) {
        st.gid = -1;
      } else {
        st.vz += (132 - st.z) * 34 * dt;
        st.laneT += (g.l - st.laneT) * Math.min(1, dt * 10);
        st.boost = Math.max(st.boost, 95);
      }
    }

    st.vz -= 1750 * dt;
    if (st.slide > 0 && st.z > 0) st.vz -= 700 * dt;
    st.z += st.vz * dt;

    if (st.z <= 0) {
      if (st.vz < -900) burst(laneX(st.lane), baseY + 10, "#9eb4df", 7, 45);
      st.z = 0;
      st.vz = 0;
      st.j2 = 1;
    }

    checkCollisions();

    st.score = (st.score + (st.speed * 0.033 + st.boost * 0.02) * dt) | 0;

    spawnRandom();

    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.t -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 250 * dt;
      if (p.t <= 0) particles.splice(i, 1);
    }
  }

  function drawTrack() {
    const g = x.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "#1f2b42");
    g.addColorStop(0.45, "#131a29");
    g.addColorStop(1, "#0a0d13");
    x.fillStyle = g;
    x.fillRect(0, 0, W, H);

    x.fillStyle = "#0d1320";
    x.fillRect(0, 0, W * 0.12, H);
    x.fillRect(W * 0.88, 0, W * 0.12, H);

    x.fillStyle = "#2a3242";
    x.fillRect(W * 0.16, 0, W * 0.68, H);

    x.fillStyle = "#4f5f7f";
    const dash = 56;
    const off = (st.p * 1.2) % dash;
    for (let y = -dash; y < H + dash; y += dash) {
      const yy = y + off;
      x.fillRect(W * 0.39, yy, 4, 28);
      x.fillRect(W * 0.61, yy, 4, 28);
    }

    x.fillStyle = "#8aa2d6";
    const winShift = (st.p * 0.5) % 36;
    for (let yy = -40; yy < H + 40; yy += 36) {
      const py = yy + winShift;
      x.fillRect(8, py, 14, 16);
      x.fillRect(W - 22, py + 8, 14, 14);
    }

    x.fillStyle = "#131b2a";
    x.fillRect(0, baseY + 18, W, H - baseY);
  }

  function drawAnchor(a) {
    const sy = baseY - (a.y - st.p) * 0.9 - 95;
    if (sy < -60 || sy > H + 50) return;
    const sx = laneX(a.l);
    const pulse = 1 + Math.sin(st.t * 7 + a.y * 0.03) * 0.14;
    x.strokeStyle = a.used ? "#476074" : "#f6c54f";
    x.lineWidth = 3;
    x.beginPath();
    x.arc(sx, sy, 12 * pulse, 0, Math.PI * 2);
    x.stroke();
    x.fillStyle = "#fff2b0";
    x.beginPath();
    x.arc(sx, sy, 3, 0, Math.PI * 2);
    x.fill();
  }

  function drawObstacle(o) {
    if (o.hit) return;

    const sy = baseY - (o.y - st.p) * 0.9;
    if (sy < -130 || sy > H + 90) return;

    if (o.t === 3) {
      x.fillStyle = "#2a3040";
      x.fillRect(W * 0.2, sy - 86, W * 0.6, 86);
      x.fillStyle = "#3f4e6f";
      x.fillRect(W * 0.2, sy - 86, W * 0.6, 11);
      x.fillStyle = "#5c6a8a";
      x.fillRect(W * 0.22, sy - 65, W * 0.56, 6);
      return;
    }

    const sx = laneX(o.l);

    if (o.t === 0) {
      x.fillStyle = "#d23a57";
      x.fillRect(sx - 22, sy - 30, 44, 30);
      x.fillStyle = "#f16f86";
      x.fillRect(sx - 22, sy - 30, 44, 6);
      return;
    }

    if (o.t === 1) {
      x.fillStyle = "#7988ad";
      x.fillRect(sx - 26, sy - 62, 52, 10);
      x.fillStyle = "#4a5775";
      x.fillRect(sx - 24, sy - 52, 8, 52);
      x.fillRect(sx + 16, sy - 52, 8, 52);
      return;
    }

    if (o.t === 2) {
      x.fillStyle = "#3f4d6a";
      x.fillRect(sx - 24, sy - 84, 48, 84);
      x.fillStyle = "#7b8bb1";
      x.fillRect(sx - 24, sy - 84, 48, 8);
      return;
    }

    if (o.t === 4) {
      x.fillStyle = "#ffd966";
      x.beginPath();
      x.moveTo(sx, sy - 24);
      x.lineTo(sx + 12, sy - 12);
      x.lineTo(sx, sy);
      x.lineTo(sx - 12, sy - 12);
      x.closePath();
      x.fill();
      return;
    }

    if (o.t === 5) {
      x.fillStyle = "#ffb267";
      x.fillRect(sx - 12, sy - 20, 24, 16);
      x.strokeStyle = "#ffd4aa";
      x.lineWidth = 3;
      x.beginPath();
      x.arc(sx + 13, sy - 13, 6, -1.2, 1.2);
      x.stroke();
      return;
    }
  }

  function drawDog() {
    const px = laneX(st.lane);
    const py = baseY - st.z * 0.34;

    if (st.gid >= 0) {
      const a = anchors[st.gid];
      if (a) {
        const ax = laneX(a.l);
        const ay = baseY - (a.y - st.p) * 0.9 - 95;
        x.strokeStyle = "#f4db8a";
        x.lineWidth = 2.5;
        x.beginPath();
        x.moveTo(px + 10, py - 10);
        x.lineTo(ax, ay);
        x.stroke();
      }
    }

    x.save();
    x.translate(px, py);
    x.rotate(st.wall > 0 ? (st.laneT > st.lane ? -0.18 : 0.18) : 0);

    const run = Math.sin(st.t * 16 + st.p * 0.05) * 3;
    const slideSquash = st.slide > 0 ? 0.6 : 1;

    x.fillStyle = "#06080b";

    x.beginPath();
    x.ellipse(-4, -8, 23, 15 * slideSquash, 0, 0, Math.PI * 2);
    x.fill();

    x.beginPath();
    x.arc(17, -14 * slideSquash, 10, 0, Math.PI * 2);
    x.fill();

    x.beginPath();
    x.moveTo(18, -25 * slideSquash);
    x.lineTo(22, -36 * slideSquash);
    x.lineTo(12, -27 * slideSquash);
    x.closePath();
    x.fill();

    x.beginPath();
    x.moveTo(-18, -14 * slideSquash);
    x.lineTo(-31, -16 * slideSquash);
    x.lineTo(-20, -8 * slideSquash);
    x.closePath();
    x.fill();

    x.fillRect(-16, -2 + run, 5, 16 * slideSquash);
    x.fillRect(-4, 0 - run, 5, 14 * slideSquash);
    x.fillRect(8, 1 + run, 5, 13 * slideSquash);

    x.strokeStyle = "#d93554";
    x.lineWidth = 6;
    x.beginPath();
    x.arc(8, -10 * slideSquash, 10, 2.7, 5.7);
    x.stroke();

    if (st.boost > 8) {
      x.fillStyle = "rgba(246,197,79,0.32)";
      x.beginPath();
      x.ellipse(-6, 2, 30 + Math.sin(st.aura) * 4, 12, 0, 0, Math.PI * 2);
      x.fill();
    }

    x.restore();

    x.fillStyle = "rgba(0,0,0,0.35)";
    x.beginPath();
    x.ellipse(px, baseY + 5, 26, 8, 0, 0, Math.PI * 2);
    x.fill();
  }

  function drawParticles() {
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      x.globalAlpha = clamp(p.t * 3, 0, 1);
      x.fillStyle = p.c;
      x.fillRect(p.x, p.y, 3, 3);
    }
    x.globalAlpha = 1;
  }

  function drawHUD() {
    x.fillStyle = "rgba(8,11,18,0.72)";
    x.fillRect(12, 12, W - 24, 70);

    x.fillStyle = "#f1f4fb";
    x.font = "700 18px Trebuchet MS, sans-serif";
    x.fillText("HAMISH CAMPUS SPRINT", 22, 34);

    x.font = "600 15px Trebuchet MS, sans-serif";
    x.fillStyle = "#9ec7ff";
    x.fillText("Score " + (st.score | 0), 22, 58);
    x.fillStyle = "#ffd970";
    x.fillText("Notes " + st.notes, 136, 58);
    x.fillStyle = "#ffb56d";
    x.fillText("Coffee " + st.coffee, 226, 58);

    x.fillStyle = "#d9e2f9";
    x.fillText("Best " + st.best, W - 92, 58);

    if (st.combo > 1 && st.comboT > 0) {
      x.fillStyle = "rgba(9,13,22,0.8)";
      x.fillRect(W * 0.5 - 66, 92, 132, 34);
      x.fillStyle = "#62f0c2";
      x.font = "700 19px Trebuchet MS, sans-serif";
      x.fillText("x" + st.combo + " COMBO", W * 0.5 - 48, 115);
    }

    if (st.hintT > 0 && st.started && !st.dead) {
      let hint = "Tap center to jump/double-jump";
      if (st.p > 170) hint = "Tap side lanes to wallrun";
      if (st.p > 300) hint = "Swipe down to slide";
      if (st.p > 430) hint = "Hold near yellow ring to grapple";
      if (st.p > 630) hint = "Chain moves for combo points";

      x.fillStyle = "rgba(7,10,16,0.78)";
      x.fillRect(16, H - 96, W - 32, 52);
      x.fillStyle = "#f5f8ff";
      x.font = "600 16px Trebuchet MS, sans-serif";
      x.fillText(hint, 26, H - 64);
    }

    if (!st.started) {
      x.fillStyle = "rgba(7,10,16,0.84)";
      x.fillRect(20, H * 0.2, W - 40, H * 0.6);

      x.fillStyle = "#ffffff";
      x.font = "700 34px Trebuchet MS, sans-serif";
      x.fillText("WHAT THE", W * 0.5 - 95, H * 0.35);
      x.fillStyle = "#ff4d70";
      x.fillText("DOG DOING?", W * 0.5 - 108, H * 0.41);

      x.fillStyle = "#d5def8";
      x.font = "600 18px Trebuchet MS, sans-serif";
      x.fillText("Center tap: jump", W * 0.5 - 82, H * 0.52);
      x.fillText("Side tap: wallrun", W * 0.5 - 88, H * 0.57);
      x.fillText("Swipe down: slide", W * 0.5 - 90, H * 0.62);
      x.fillText("Hold near ring: grapple", W * 0.5 - 106, H * 0.67);

      x.fillStyle = "#62f0c2";
      x.font = "700 22px Trebuchet MS, sans-serif";
      x.fillText("Tap anywhere to start", W * 0.5 - 112, H * 0.76);
    }

    if (st.dead) {
      x.fillStyle = "rgba(6,8,12,0.86)";
      x.fillRect(24, H * 0.24, W - 48, H * 0.48);
      x.fillStyle = "#ff7f95";
      x.font = "700 30px Trebuchet MS, sans-serif";
      x.fillText("MISSED THE DEFENSE", W * 0.5 - 152, H * 0.38);

      x.fillStyle = "#dce7ff";
      x.font = "600 20px Trebuchet MS, sans-serif";
      x.fillText("Score " + (st.score | 0), W * 0.5 - 58, H * 0.47);
      x.fillText("Best " + st.best, W * 0.5 - 50, H * 0.53);
      x.fillStyle = "#ffcf7c";
      x.fillText(st.reason || "Try again", W * 0.5 - 72, H * 0.59);

      x.fillStyle = "#62f0c2";
      x.font = "700 23px Trebuchet MS, sans-serif";
      x.fillText("Tap to retry", W * 0.5 - 62, H * 0.67);
    }
  }

  function render() {
    const s = st.shake > 0 ? (Math.random() - 0.5) * 8 * st.shake : 0;
    x.setTransform(dpr, 0, 0, dpr, s, 0);

    drawTrack();

    for (let i = 0; i < anchors.length; i++) drawAnchor(anchors[i]);
    for (let i = 0; i < obs.length; i++) drawObstacle(obs[i]);

    drawDog();
    drawParticles();
    drawHUD();

    if (st.flash > 0) {
      x.fillStyle = "rgba(255,255,255," + (st.flash * 0.35) + ")";
      x.fillRect(-20, -20, W + 40, H + 40);
    }
  }

  function step(ts) {
    if (!lastFrame) lastFrame = ts;
    let dt = (ts - lastFrame) * 0.001;
    lastFrame = ts;
    dt = clamp(dt, 0, 0.034);

    update(dt);
    render();

    requestAnimationFrame(step);
  }

  function handlePointerDown(e) {
    if (pointerId >= 0 && pointerId !== e.pointerId) return;
    pointerId = e.pointerId;
    c.setPointerCapture(pointerId);

    downX = e.clientX;
    downY = e.clientY;
    downT = performance.now();

    if (!audio) {
      audio = new (window.AudioContext || window.webkitAudioContext)();
    }

    if (!st.started) {
      st.started = 1;
      reset();
      sfx(440, 0.05, "triangle", 0.025);
      return;
    }

    if (st.dead) {
      reset();
      sfx(400, 0.05, "triangle", 0.02);
      return;
    }

    st.hold = 1;

    const px = e.clientX;
    const py = e.clientY;

    if (py > H * 0.42) {
      if (px < W * 0.33) moveSide(-1);
      else if (px > W * 0.67) moveSide(1);
      else jump();
    }
  }

  function handlePointerMove(e) {
    if (pointerId !== e.pointerId) return;
    if (st.dead || !st.started) return;
    const dy = e.clientY - downY;
    const dx = e.clientX - downX;
    if (dy > 44 && Math.abs(dx) < 82) {
      slide();
      downY = e.clientY + 999;
    }
  }

  function handlePointerUp(e) {
    if (pointerId !== e.pointerId) return;
    const dt = (performance.now() - downT) * 0.001;
    const dy = e.clientY - downY;
    const dx = e.clientX - downX;
    if (!st.dead && st.started && dy > 40 && Math.abs(dx) < 88 && dt < 0.42) slide();
    st.hold = 0;
    st.gid = -1;
    if (c.hasPointerCapture(pointerId)) c.releasePointerCapture(pointerId);
    pointerId = -1;
  }

  window.addEventListener("resize", resize);
  c.addEventListener("pointerdown", handlePointerDown, { passive: true });
  c.addEventListener("pointermove", handlePointerMove, { passive: true });
  c.addEventListener("pointerup", handlePointerUp, { passive: true });
  c.addEventListener("pointercancel", handlePointerUp, { passive: true });

  resize();
  seedTutorial();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
